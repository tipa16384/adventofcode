picotron cartridge // www.picotron.net
version 2

:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTEyIDE0OjQ5OjMwIixtb2RpZmllZD0iMjAyNS0x
Mi0wMiAwMDowMDozNCIscnVudGltZT0yMSx3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
IzM4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJpbnB1dC50eHQjMTAiLHdvcmtzcGFj
ZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2Nh
dGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M319XV0=
:: gfx/
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTEyIDE0OjQ5OjMwIixtb2RpZmllZD0iMjAyNS0x
Mi0wMiAwMDowMDozNCJdXQ==
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNS0x
Mi0wMiAwMDowMDozNCIscmV2aXNpb249MzVdXWx6NACrAwAA6T0AAPMhe1swXT17Ym1wPXB4dQBD
IBAQBPBWBxAHwBfQF8AHEAfwVixmbGFncz0wLHBhbl94CADLeT0wLHpvb209OH0sPgAf8DEAHB-3
MQAdMQAHIAIAMhAnAAIAL-fQcwAdMbIEJwIAMBckBwIAQfQFACQCAB8ESQAcL-8YvQAdL9cUAgAL
D24BSpMHDQQASgAKQBoCACcKYAwAPwBKAEwAHDPAClACAAYKAB9gkAAeE2A6ABBQggADCgBfUApg
SgBKACoJVgAP2AAcChYBH2DcACgI0AAOkgAPSgAlHwC2ASoI0gAfwNwAKgOEAAKGAA_UACwKQAAP
vgEpYwBLAAtAGwIANYtAGwIAHwtJABwXW0gAGWsMAA_SACAfUAIAAD9gSwCTACgIAgAPkwAeM3tQ
CwIAF1ucAB9rRgAyLwtQ1gAhAzsAPwsgG2sBKQgfAQ-8ASkvUAsCAAUPSQAvAZAALwBL2wAg8gAw
CwALIAsQCxALIAsACzBJACELMBAAABgAACAAD_0AIC4LUAIADw8CIe0LQCsgKwALAAsAGxALEAQA
H0CNASWBC0ArMBsACyBGAGMgCwAbMCtKAA5QAA8iBB4IAgAvCwCSAyoeawUDD5UAKwXwAD8bAFuY
ACsPJgIwJgBLpwM0YEtgzAIPNAEgT2sgC1ACAAIfIBkCHh8byAE1HwtHAAIBMgE-AAtAmgArCAUD
AAQAASMDXysgK0ALVgAgAwMEApkAAcsBIwtACgATIBoAD98BIiRgC68AAD8BPzALUJYBJlRrUAtA
CwQABgoAL1Br3AotYy0wLjEyNTYAETIMAA86ALEE0AwSFM4MPxcU1yAMCA9lACUv1xQCAAMSFwoN
KRQHCg0vNABoACXyF0A7kEs-GUArDw8bXxkgOx8PXxkwCwAbLw8PGR8PDxoPD1ALHxkfDgCwGS8P
QC8ZXw9wOz4WAP8VGy4dDkBNLgsNDjALTR4bDUAbPSsNQB1LPQswLXsdMC1ALfAElwAl8QPwArYg
FpcWEAYHnxYHBhAGB54GAHEeBgoGLgoODABUDgYqBh4MAE8aCRoeGAAACDAAFZ4GAABZAH-WENYQ
FpAWOAEm8A7wBy8VsA4fFw6wDh0OoA49DpAOPQ5gPjc_IA6nDgQA-wkwPjc_YFWAdWCVQCUwRSAv
GFAsMCxQLCDqAicPOgD---------------------------------------------------------
----BFBtPTh9fQ==
:: input.txt
--[[pod_format="raw",created="2025-12-01 00:26:53",modified="2025-12-01 23:18:11",revision=3]]
L68
L30
R48
L5
R60
L55
L1
L99
R14
L82
:: main.lua
--[[pod_format="raw",created="2025-12-01 00:13:48",modified="2025-12-01 23:11:27",revision=127]]

input_lines = nil
log = {}
max_lines_to_display = 18
line_height = 10
frame_count = 0
current_line = 0
part1_value = 0
part2_value = 0

current_position = 50
link_jump_start = -1
safe_jump_start = -1

function read_input_numbers()
	numbers = {}
	for line in data:gmatch("[^\r\n]+") do
   	 numbers[#numbers+1] = tonumber(line)
	end    
   
   return numbers
end

function read_input_strings(source)
	strings = {}
	for line in source:gmatch("[^\r\n]+") do
   	 strings[#strings+1] = line
	end    
   
   return strings
end

function add_to_log(string)
	log[#log+1] = string
end

function _init()
	local content = fetch("input.txt")
	if content then
		add_to_log("File found!")
		input_lines = read_input_strings(content)
		add_to_log("Read " .. #input_lines .. " lines of input.")
	else
		add_to_log("Nope, no luck.")
		input_lines = {}
	end
	add_to_log("")
end

function _draw()
	-- use locals instead of implicitly creating globals
	local top_x  = 90
	local top_y  = 120 - line_height
	local text_x_offset = 40
	local text_y_offset = 0

	-- precompute common positions
	local base_x = top_x + text_x_offset
	local base_y = top_y + text_y_offset

	camera(top_x, top_y)
	cls()
	map()

	-- cache #log and first index
	local log_count   = #log
	local first_index = max(1, log_count - max_lines_to_display + 1)

	-- starting y for log entries (same "+5" as your original)
	local start_y = base_y + 5 * line_height

	for i = first_index, log_count do
		-- avoid recomputing top_x + offset every time
		local y = start_y + (i - first_index) * line_height
		print(log[i], base_x, y, 12)
	end
	
	camera(0,0)
	lcd_string("PART 1", 256, 40)
	lcd_string(string.format("%08d", part1_value), 256, 60)
	lcd_string("PART 2", 256, 100)
	lcd_string(string.format("%08d", part2_value), 256, 120)
	
	lcd_string("ADVENT OF CODE", 256, 170)
	lcd_string("2025 DAY 1", 256, 190)
	
	spr(50, 246, 226 + jump_offset(link_jump_start))
	spr(51, 262, 226 + jump_offset(safe_jump_start))
end

function jump_offset(state)
	if state < 0 then
		return 0
	end
	local t = frame_count - state
   return (16/45) * t * (t - 15)
end

function lcd_string(s, x, y)
	local sprite_width = 9
	local byte_0 = string.byte("0")
	local byte_9 = string.byte("9")
	local byte_a = string.byte("A")
	local byte_z = string.byte("Z")
	local num_base = 8
	local alpha_base = 18
	
	for i = 1, #s do
		local char = string.byte(s, i)
		local sprite = nil
		if char >= byte_0 and char <= byte_9 then
			sprite = num_base + char - byte_0
		elseif char >= byte_a and char <= byte_z then
			sprite = alpha_base + char - byte_a
		end
		if sprite then
			local dx = sprite_width * (i - 1)
			spr(sprite, x + dx, y)
		end
	end
end
 
function _update()
	frame_count = frame_count + 1

	if link_jump_start < 0 and btnp(0) then
		link_jump_start = frame_count
	elseif link_jump_start >= 0 and frame_count > link_jump_start + 15 then
		link_jump_start = -1
	end	

	if safe_jump_start < 0 and btnp(1) then
		safe_jump_start = frame_count
	elseif safe_jump_start >= 0 and frame_count > safe_jump_start + 15 then
		safe_jump_start = -1
	end	

	if (frame_count % 1 == 0) and (current_line < #input_lines) then
		current_line = current_line + 1
		local spins = input_lines[current_line]
		local lr = string.sub(spins, 1, 1)
		local number = tonumber(string.sub(spins, 2, #spins))
		local old_position = current_position
		local crossed = number // 100
		local notes = ""
		
		number = number % 100
		if lr == "L" then
			current_position = (current_position - number)
		else
			current_position = (current_position + number)
		end
		if ((lr == "L" and current_position < 0 and old_position > 0) or
			 (lr == "R" and current_position >= 100) or
			 (current_position % 100 == 0)) then
			crossed = crossed + 1
		end
		if crossed > 0 then
			part2_value = part2_value + crossed
			if crossed == 1 then
				notes = "crossed zero once"
			else
				notes = "crossed zero " .. crossed .. " times"
			end
		end
		current_position = current_position % 100
		add_to_log(string.format("%s %3d %2d %s", lr, number, current_position, notes))
		if current_position == 0 then
			part1_value = part1_value + 1
		end
	end
end
:: map/
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTEyIDE0OjQ5OjMwIixtb2RpZmllZD0iMjAyNS0x
Mi0wMiAwMDowMDozNCJdXQ==
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNS0x
Mi0wMSAyMjo1MjowNyIscmV2aXNpb249MjBdXWx6NACUAAAAWwEAAPIre3tibXA9cHh1AEyAICAA
yAAABQEAFQAACQEABAAABgEACQAAFgEACAAAAQEACwMAADAAAAEACgUABBIATwIAAAYSAFoVB40A
Dw8AKUMEAAAxDwAfFgYAB-EKowAALGhpZGRlbj1mYWxzZSxwYW5feD05NgkA0nk9MCx0aWxlX2g9
MTYKABB3CgCAem9vbT0xfX0=
:: sfx/
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTEyIDE0OjQ5OjMwIixtb2RpZmllZD0iMjAyNS0x
Mi0wMiAwMDowMDozNCJdXQ==
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA3LTMxIDA4OjMwOjI4Iixtb2RpZmllZD0iMjAyNS0w
Ny0zMSAwODozMDoyOCIscmV2aXNpb249MF1dbHo0AKAAAAALCgAA-zBweHUAAygAAAQABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oBEAYP
MBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA------_9
H-8BAKzPyA9AAA8QQP--sPD-AQD-6lD-----KQ==
:: [eoc]
